<!DOCTYPE html> <html lang= "en"> <head> <meta charset= "utf-8"/> <meta name=
"viewport" content= "width=device-width, initial-scale=1" />

<script src="https://d3js.org/d3.v7.min.js"></script> <!-- d3 import -->
<script src="http://d3js.org/topojson.v1.min.js"></script>

<title>INFO 3300 Project 2 </title> </head>

<body><p id="p1">
  <h1> Visualization 1 </h1>

  <svg id= "map" height="700" width="800" />
  <svg id= "countryChart" height="500" width="500" />

  <script>

      const drawMap = async () => {

      // Initialize datasets
      const worldmap = await d3.json("countries-50m.json");
      const happinessreport = await d3.csv("2019.csv");

      ////////////////////////// Data Cleaning /////////////////////////////////
      // List of names that need to be manually matched between datasets

      happinessreport[18]["Country or region"] = "United States of America" // "United States"
      happinessreport[19]["Country or region"] = "Czechia" // "Czech Republic"
      happinessreport[38]["Country or region"] = "Trinidad and Tobago" // "Trinidad & Tobago"
      happinessreport[76]["Country or region"] = "Dominican Rep." // "Dominican Republic"
      happinessreport[77]["Country or region"] = "Bosnia and Herz." // "Bosnia and Herzegovina"
      happinessreport[102]["Country or region"] = "Congo" // "Congo (Brazzaville)"
      happinessreport[109]["Country or region"] = "Palestine" // "Palestinian Territories"
      happinessreport[126]["Country or region"] = "Dem. Rep. Congo" // "Congo (Kinshasha)"
      happinessreport[134]["Country or region"] = "eSwatini" // "Swaziland"
      happinessreport[154]["Country or region"] = "Central African Rep." // "Central African Republic"
      happinessreport[155]["Country or region"] = "S. Sudan" // "South Sudan"

      // Places to drop from happiness report
      //happinessreport[63]["Country or region"] = "-" // "Northern Cyprus" --> Cyprus
      //happinessreport[83]["Country or region"] = "-" // "North Macedonia" --> Macedonia?
      //happinessreport[98]["Country or region"] = "-" // "Ivory Coast" --> drop?

      // Worldmap country names list
      let worldmap_names = [];
      worldmap.objects.countries.geometries.forEach( (d, i) => {
        worldmap_names.push(d.properties.name);
      });

      // Happinessreport country names list
      let happiness_names = [];
      happinessreport.forEach( (d, i) => {
        happiness_names.push(d["Country or region"]);
      });

      const names_to_fix = happiness_names.filter(element => !worldmap_names.includes(element));
      //console.log(names_to_fix);
      //////////////////////////////////////////////////////////////////////////

      // Initialize constants for map generation
      const countries = topojson.feature(worldmap, worldmap.objects.countries);
      const countriesMesh = topojson.mesh(worldmap, worldmap.objects.countries);
      const landMesh = topojson.mesh(worldmap, worldmap.objects.land);

      let map = d3.select("svg#map");
      let mapWidth = map.attr("width");
      let mapHeight = map.attr("height");
      let projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      let path = d3.geoPath().projection(projection);

      // Color scale(s)
      const happinessExtent = d3.extent(happinessreport, d => d["Score"]);
      const happiness_color_scale = d3.scaleSequential(d3.interpolateGnBu).domain(happinessExtent);
      const happinessScale = d3.scaleLinear().domain(happinessExtent).range([10, 100]); //scale for radius of pie chart

      let viewport = map.append("g"); // g tag for map elements

      // Draw countries and their mesh lines
      let mycountries = viewport.selectAll(".countries").data(countries.features)
              .enter()
              .append("path")
              .attr("class","countries")
              .attr("d", path)
              .attr("fill", d => get_fills(d) );

      country_lines = viewport.append("path").datum(countriesMesh)
                              .attr("class","country-outline")
                              .attr("d", path)
                              .attr("fill" ,"none")
                              .attr("stroke", "black")
                              .attr("stroke-width", 0.5);

      // Draw land mesh lines
      land_lines = viewport.append("path").datum(landMesh)
                           .attr("class","land-outline")
                           .attr("d", path)
                           .attr("fill" ,"none")
                           .attr("stroke", "black")
                           .attr("stroke-width", 0.75);

      // Zoom Generator
      var zoom = d3.zoom()
                   .scaleExtent([1,10])
                   .translateExtent([[-50,-50],[mapWidth+50,mapHeight+50]])  // to lock to edges
                   .on("zoom", mapZoom);

      map.call(zoom);
      map.call(zoom.transform, d3.zoomIdentity);

      ////////////////////////////// Functions /////////////////////////////////
      function mapZoom({transform}) {
        // Transform the group object to reflect the zoom action
        viewport.attr("transform", transform.toString());

        // Modify the stroke-width of the mesh so the width remains the same regardless of the zoom level
        viewport.select(".county-outline")
                .style("stroke-width", 0.5 / transform.k);
        viewport.select(".state-outline")
                .style("stroke-width", 0.75 / transform.k);
        }

      function get_fills(country_feature) {
          // Map the worldmap country with the happiness country and get the
          // relevant data. If there is a match, color according to the color
          // scale of the feature. If there is not a match, color light gray

          country_info = happinessreport.filter(function(k) {return k["Country or region"] === country_feature.properties.name})[0];

          try {
            score = parseFloat(country_info["Score"]);
          } catch (TypeError) {
            score = 0;
            // console.log("caught");
          }

          if (score === 0) {
            return "lightgray";
          } else {
            return happiness_color_scale(score);
          }
      }
      //////////////////////////////////////////////////////////////////////////

      // ---- Country Chart Set Up ----
      const svg_country = d3.select("svg#countryChart");
      const width = svg_country.attr("width");
      const height = svg_country.attr("height");
      const margin = {top: 10, right: 10, bottom: 10, left: 10};
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      let annotations = svg_country.append("g").attr("id","annotations");
      let chartArea = svg_country.append("g").attr("id","points")
                      .attr("transform",`translate(${margin.left},${margin.top})`);

      let background = chartArea.append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", chartWidth)
          .attr("height", chartHeight)
          .attr("fill", "lightgrey")
          .attr("rx", 20)
          .attr("ry", 20)



      // PIE CHART
      //var data = [10, 5, 4, 6];
      //var data = [0, 0, 0, 0];
      var color = d3.scaleOrdinal(["red", "orange", "yellow", "green", "blue", "purple"]);
      var pie = d3.pie();

      // ON CLICK Function
      mycountries.on("click", function() {

        // redraw the background...
        let background = chartArea.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", chartWidth)
            .attr("height", chartHeight)
            .attr("fill", "lightgrey")
            .attr("rx", 20)
            .attr("ry", 20)

        // country name drawn
        let name = chartArea.append("text")
            .attr("x", width/2)
            .attr("y", 50)
            .attr("text-anchor", "middle")
            .style("font-size", 30)
            .style("opacity", "1")
            .text(d3.select(this).datum().properties.name)

        // --- Pie Chart appears ---
        this_country = happinessreport.filter(d => d["Country or region"] == d3.select(this).datum().properties.name);
        let rank = this_country[0]["Overall rank"];
        let freedom = this_country[0]["Freedom to make life choices"];
        let gdp = this_country[0]["GDP per capita"];
        let generosity = this_country[0]["Generosity"];
        let life_expectancy = this_country[0]["Healthy life expectancy"];
        let corruption = this_country[0]["Perceptions of corruption"];
        let social_support = this_country[0]["Social support"];
        let score = this_country[0]["Score"];
        var data = [freedom, gdp, generosity, life_expectancy, corruption, social_support];

        //var radius = 100;
        var radius = happinessScale(score);

        var arc = d3.arc()
                  .innerRadius(0) // increase for donut chart
                  .outerRadius(radius);

        var arcs = chartArea.selectAll("arc")
                  .data(pie(data))
                  .enter()
                  .append("g")
                  .attr("class", "arc")
                  .attr("transform",`translate(${width/2},${height/2})`);

        arcs.append("path")
          .attr("fill", function(d, i) {
              return color(i);
          })
          .attr("d", arc);

      });

      mycountries.on("mouseover", function() {
        //TODO: alter opacity or stroke or size of country upon mousover
      });

      mycountries.on("mouseout", function() {
        //TODO: return to natural state after mouseover

      });

    } // end of async function

    drawMap();


    </script>

  </p></body>
