<!DOCTYPE html> <html lang= "en"> <head> <meta charset= "utf-8"/> <meta name=
"viewport" content= "width=device-width, initial-scale=1" />

<script src="https://d3js.org/d3.v7.min.js"></script> <!-- d3 import -->
<script src="http://d3js.org/topojson.v1.min.js"></script>

<title>INFO 3300 Project 2 </title> </head>

<body><p id="p1">
  <h1> Visualization 1 </h1>

  <svg id= "map" height="700" width="800" />

  <script>

      const drawMap = async () => {

      // Initialize datasets
      const worldmap = await d3.json("countries-50m.json");
      const happinessreport = await d3.csv("2019.csv");

      ////////////////////////// Data Cleaning /////////////////////////////////
      // Worldmap country names list
      worldmap_names = [];
      worldmap.objects.countries.geometries.forEach( (d, i) => {
        worldmap_names.push(d.properties.name);
      });

      // Happinessreport country names list
      happiness_names = [];
      happinessreport.forEach( (d, i) => {
        happiness_names.push(d["Country or region"]);
      });

      // List of names that need to be manually matched between datasets
      // TODO: Katherine
      const names_to_fix = happiness_names.filter(element => !worldmap_names.includes(element));
      console.log(names_to_fix);
      //////////////////////////////////////////////////////////////////////////

      // Initialize constants for map generation
      const countries = topojson.feature(worldmap, worldmap.objects.countries);
      const countriesMesh = topojson.mesh(worldmap, worldmap.objects.countries);
      const landMesh = topojson.mesh(worldmap, worldmap.objects.land);

      let map = d3.select("svg#map");
      let mapWidth = map.attr("width");
      let mapHeight = map.attr("height");
      let projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      let path = d3.geoPath().projection(projection);

      let viewport = map.append("g"); // g tag for map elements

      // Draw countries and their mesh lines
      viewport.selectAll(".countries").data(countries.features)
              .enter()
              .append("path")
              .attr("class","countries")
              .attr("d", path)
              .attr("fill", "gray"); // CHANGE BASED ON HAPPINESS DATA

      country_lines = viewport.append("path").datum(countriesMesh)
                              .attr("class","country-outline")
                              .attr("d", path)
                              .attr("fill" ,"none")
                              .attr("stroke", "black")
                              .attr("stroke-width", 0.5);

      // Draw land mesh lines
      land_lines = viewport.append("path").datum(landMesh)
                           .attr("class","land-outline")
                           .attr("d", path)
                           .attr("fill" ,"none")
                           .attr("stroke", "black")
                           .attr("stroke-width", 0.75);

      // Zoom Generator
      var zoom = d3.zoom()
                   .scaleExtent([1,10])
                   .translateExtent([[-50,-50],[mapWidth+50,mapHeight+50]])  // to lock to edges
                   .on("zoom", mapZoom);

      map.call(zoom);
      map.call(zoom.transform, d3.zoomIdentity);

      function mapZoom({transform}) {
        // Transform the group object to reflect the zoom action
        viewport.attr("transform", transform.toString());

        // Modify the stroke-width of the mesh so the width remains the same regardless of the zoom level
        viewport.select(".county-outline")
                .style("stroke-width", 0.5 / transform.k);
        viewport.select(".state-outline")
                .style("stroke-width", 0.75 / transform.k);
        }

      console.log(happinessreport);

    }

    drawMap();


    </script>

  </p></body>
