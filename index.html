<!DOCTYPE html>
<html lang= "en">
  <head>
    <meta charset= "utf-8"/> <meta name="viewport" content= "width=device-width, initial-scale=1" />

  <script src="https://d3js.org/d3.v7.min.js"></script> <!-- d3 import -->
  <script src="http://d3js.org/topojson.v1.min.js"></script>

  <title>INFO 3300 Project 2 </title>
  <style>
      .gridlines .domain {
        display: none;
      }

      .gridlines line {
        stroke: #a1a1a1;
      }
  </style>
</head>

<body>
  <p id="p1">

    <h1>INFO 3300 Project 2</h1>
    <h3>by Fatima Yuen (fy46), Katherine Vella (skv25), Lea Jih-Vieira (laj74), Taerim Eom (te89)</h3>

    <svg id= "map" height="480" width="500"
        style="border:1px solid black; border-radius: 20px"></svg>
    <svg id= "countryChart" height="480" width="400" ></svg>
    <svg id="linePlot" width="400" height="480"></svg>
    <svg id="maplegend" width="500" height="40"></svg>

    <script>

        const drawMap = async () => {

        // Initialize datasets
        const worldmap = await d3.json("countries-50m.json");
        const happinessreport = await d3.csv("2019.csv");

        ////////////////////////// Data Cleaning /////////////////////////////////
        // List of names that need to be manually matched between datasets

        happinessreport[18]["Country or region"] = "United States of America" // "United States"
        happinessreport[19]["Country or region"] = "Czechia" // "Czech Republic"
        happinessreport[38]["Country or region"] = "Trinidad and Tobago" // "Trinidad & Tobago"
        happinessreport[76]["Country or region"] = "Dominican Rep." // "Dominican Republic"
        happinessreport[77]["Country or region"] = "Bosnia and Herz." // "Bosnia and Herzegovina"
        happinessreport[102]["Country or region"] = "Congo" // "Congo (Brazzaville)"
        happinessreport[109]["Country or region"] = "Palestine" // "Palestinian Territories"
        happinessreport[126]["Country or region"] = "Dem. Rep. Congo" // "Congo (Kinshasha)"
        happinessreport[134]["Country or region"] = "eSwatini" // "Swaziland"
        happinessreport[154]["Country or region"] = "Central African Rep." // "Central African Republic"
        happinessreport[155]["Country or region"] = "S. Sudan" // "South Sudan"

        // Places to drop from happiness report
        //happinessreport[63]["Country or region"] = "-" // "Northern Cyprus" --> Cyprus
        //happinessreport[83]["Country or region"] = "-" // "North Macedonia" --> Macedonia?
        //happinessreport[98]["Country or region"] = "-" // "Ivory Coast" --> drop?

        // Worldmap country names list
        let worldmap_names = [];
        worldmap.objects.countries.geometries.forEach( (d, i) => {
          worldmap_names.push(d.properties.name);
        });

        // Happinessreport country names list
        let happiness_names = [];
        happinessreport.forEach( (d, i) => {
          happiness_names.push(d["Country or region"]);
        });

        const names_to_fix = happiness_names.filter(element => !worldmap_names.includes(element));
        //console.log(names_to_fix);
        //////////////////////////////////////////////////////////////////////////

        // Initialize constants for map generation
        const countries = topojson.feature(worldmap, worldmap.objects.countries);
        const countriesMesh = topojson.mesh(worldmap, worldmap.objects.countries);
        const landMesh = topojson.mesh(worldmap, worldmap.objects.land);

        let map = d3.select("svg#map");
        let mapWidth = map.attr("width");
        let mapHeight = map.attr("height");
        let projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
        let path = d3.geoPath().projection(projection);

        // Color scale(s)
        const happinessExtent = d3.extent(happinessreport, d => d["Score"]);
        const minScore = d3.min(happinessreport, d => d["Score"]);
        const maxScore = d3.max(happinessreport, d => d["Score"]);

        const happiness_color_scale = d3.scaleSequential(d3.interpolateYlGnBu).domain([maxScore,minScore]);
        const happinessScale = d3.scaleLinear().domain(happinessExtent).range([10, 100]); //scale for radius of pie chart

        let viewport = map.append("g"); // g tag for map elements

        // Draw countries and their mesh lines
        let mycountries = viewport.selectAll(".countries").data(countries.features)
                .enter()
                .append("path")
                .attr("class","countries")
                .attr("d", path)
                .attr("fill", d => get_fills(d) );

        country_lines = viewport.append("path").datum(countriesMesh)
                                .attr("class","country-outline")
                                .attr("d", path)
                                .attr("fill" ,"none")
                                .attr("stroke", "black")
                                .attr("stroke-width", 0.5);

        // Draw land mesh lines
        land_lines = viewport.append("path").datum(landMesh)
                             .attr("class","land-outline")
                             .attr("d", path)
                             .attr("fill" ,"none")
                             .attr("stroke", "black")
                             .attr("stroke-width", 0.75);

        // Zoom Generator
        var zoom = d3.zoom()
                     .scaleExtent([1, 2.5])
                     .translateExtent([[-50, -50],[mapWidth + 50, mapHeight + 50]])  // to lock to edges
                     .on("zoom", mapZoom);

        map.call(zoom);
        map.call(zoom.transform, d3.zoomIdentity);

        ////////////////////////////// Functions /////////////////////////////////
        function mapZoom({transform}) {
          // Transform the group object to reflect the zoom action
          viewport.attr("transform", transform.toString());

          // Modify the stroke-width of the mesh so the width remains the same regardless of the zoom level
          viewport.select(".county-outline")
                  .style("stroke-width", 0.5 / transform.k);
          viewport.select(".state-outline")
                  .style("stroke-width", 0.75 / transform.k);
          }

        function get_fills(country_feature) {
            // Map the worldmap country with the happiness country and get the
            // relevant data. If there is a match, color according to the color
            // scale of the feature. If there is not a match, color light gray

            country_info = happinessreport.filter(function(k) {return k["Country or region"] === country_feature.properties.name})[0];

            try {
              score = parseFloat(country_info["Score"]);
            } catch (TypeError) {
              score = 0;
              // console.log("caught");
            }

            if (score === 0) {
              return "lightgray";
            } else {
              return happiness_color_scale(score);
            }
        }
        // -- Map color scale legend --

          var data = Array.from(Array(100).keys());

          var mapScale = d3.scaleSequential(d3.interpolateYlGnBu)
              .domain([99,0]); //flipped domain to make it blue to yellow

              const svg_legend = d3.select("svg#maplegend");
              const legend_width = svg_legend.attr("width");

          var xScale = d3.scaleLinear()
              .domain([0,99])
              .range([0, legend_width]);

          var u = d3.select("#maplegend")
              .selectAll("rect")
              .data(data)
              .enter()
              .append("rect")
              .attr("x", (d) => Math.ceil(xScale(d)))
              .attr("y", 0)
              .attr("height", 40)
              .attr("width", (d) => {
                  if (d == 99) {
                      return 6;
                  }
                  return Math.ceil(xScale(d+1)) - Math.ceil(xScale(d)) + 1;
               })
              .attr("fill", (d) => mapScale(d));

        //////////////////////////////////////////////////////////////////////////

        // ---- Country Chart Set Up ----
        const svg_country = d3.select("svg#countryChart");
        const width = svg_country.attr("width");
        const height = svg_country.attr("height");
        const margin = {top: 0, right: 10, bottom: 0, left: 10};
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        let annotations = svg_country.append("g").attr("id","annotations");
        let chartArea = svg_country.append("g").attr("id","points")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        // PIE CHART
        //var data = [10, 5, 4, 6];
        //var data = [0, 0, 0, 0];
        var pie_color = d3.scaleOrdinal(["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#ffd92f","#e5c494"]);
        var pie = d3.pie();

        // --- PIE CHART DICTIONARY ---

        let pie_data = [0, 0, 0, 0, 0, 0];
        let data_dict = [
          {"label": "Freedom of life choices", "value": pie_data[0]},
          {"label": "GDP per capita", "value": pie_data[1]},
          {"label": "Generosity", "value": pie_data[2]},
          {"label": "Healthy life expectancy", "value": pie_data[3]},
          {"label": "Perceptions of corruption", "value": pie_data[4]},
          {"label": "Social support", "value": pie_data[5]},
        ];

        // GLOBAL STATS - Before country clicked
        let global_freedom_T = 0;
        let global_gdp_T = 0;
        let global_generosity_T = 0;
        let global_life_expectancy_T = 0;
        let global_corruption_T = 0;
        let global_social_support_T = 0;
        let global_score_T = 0;
        happinessreport.forEach(d => {
            global_freedom_T += Number(d['Freedom to make life choices']);
            global_gdp_T += Number(d['GDP per capita'])
            global_generosity_T += Number(d['Generosity'])
            global_life_expectancy_T += Number(d['Healthy life expectancy'])
            global_corruption_T += Number(d['Perceptions of corruption'])
            global_social_support_T += Number(d['Social support'])
            global_score_T += Number(d['Score'])
        });

        // Global avg happiness
        let happiness_score = Math.round(global_score_T/happinessreport.length*1000)/1000;

        var radius = 100;

        var arc = d3.arc()
                  .innerRadius(0) // increase for donut chart
                  .outerRadius(radius);

        function global_pie() {
          // Calculate global averages
          pie_data[0] = Math.round(global_freedom_T/happinessreport.length*1000)/1000;
          pie_data[1] = Math.round(global_gdp_T/happinessreport.length*1000)/1000;
          pie_data[2] = Math.round(global_generosity_T/happinessreport.length*1000)/1000;
          pie_data[3] = Math.round(global_life_expectancy_T/happinessreport.length*1000)/1000;
          pie_data[4] = Math.round(global_corruption_T/happinessreport.length*1000)/1000;
          pie_data[5] = Math.round(global_social_support_T/happinessreport.length*1000)/1000;

          happiness_score = Math.round(global_score_T/happinessreport.length*1000)/1000;

          data_dict = [
            {"label": "Freedom of life choices", "value": pie_data[0]},
            {"label": "GDP per capita", "value": pie_data[1]},
            {"label": "Generosity", "value": pie_data[2]},
            {"label": "Healthy life expectancy", "value": pie_data[3]},
            {"label": "Perceptions of corruption", "value": pie_data[4]},
            {"label": "Social support", "value": pie_data[5]},
          ];

          let background = chartArea.append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", chartWidth)
              .attr("height", chartHeight)
              .attr("fill", "lightgrey")
              .attr("rx", 20)
              .attr("ry", 20)

          let arcs_g = chartArea.selectAll("arc")
                    .data(pie(pie_data))
                    .enter()
                    .append("g")
                    .attr("class", "arc")
                    .attr("transform",`translate(${width/2},${2*height/5})`);

          arcs_g.append("path")
            .attr("fill", function(d, i) {
                return pie_color(i);
            })
            .attr("d", arc);

          chartArea.append("text")
              .attr("x", width/2)
              .attr("y", 50)
              .attr("text-anchor", "middle")
              .attr("font-family", "Verdana, sans-serif")
              .style("font-size", 30)
              .style("opacity", "1")
              .text("Global Happiness")

          chartArea.append("text")
              .attr("x", width/2)
              .attr("y", 75)
              .attr("text-anchor", "middle")
              .attr("font-family", "Verdana, sans-serif")
              .style("font-size", 15)
              .style("opacity", "1")
              .text("Most Recent Data (2019)")
        }
        global_pie();



        function pie_key(data_dict, happiness_score){
          data_dict.forEach( (d, i) => {
            chartArea.append("text")
              .attr("x", chartWidth/2)
              .attr("y", chartHeight - (40 + 20*i))
              .attr("font-family", "Verdana, sans-serif")
              .text(d["rank"]);

            chartArea.append("text")
              .attr("x", 50)
              .attr("y", chartHeight - (40 + 20*i))
              .attr("font-family", "Verdana, sans-serif")
              .text(d["label"] + ": ");

            chartArea.append("text")
              .attr("x", chartWidth - 50)
              .attr("y", chartHeight - (40 + 20*i))
              .attr("text-anchor", "end")
              .attr("font-family", "Verdana, sans-serif")
              .text(d["value"]);

            chartArea.append("circle")
              .attr("cx", 40)
              .attr("cy", chartHeight - (45 + 20*i))
              .attr("r", 5)
              .attr("fill", pie_color(i))
          });

          chartArea.append("line")
            .attr("x1", 35)
            .attr("x2", chartWidth - 50)
            .attr("y1", chartHeight - 30)
            .attr("y2", chartHeight - 30)
            .attr("stroke-width", 1)
            .attr("stroke", "black")

          chartArea.append("text")
            .attr("x", 50)
            .attr("y", chartHeight - 10)
            .attr("font-family", "Verdana, sans-serif")
            .text("Total Happiness Score: ");

          chartArea.append("text")
            .attr("x", chartWidth - 50)
            .attr("y", chartHeight - 10)
            .attr("text-anchor", "end")
            .attr("font-family", "Verdana, sans-serif")
            .text(happiness_score);
        }

        pie_key(data_dict, happiness_score);

        // ----------------- LINE CHART STUFF OUTSIDE OF CLICK -------------------
        let data2015 = await d3.csv("2015.csv");
        let data2016 = await d3.csv("2016.csv");
        let data2017 = await d3.csv("2017.csv");
        let data2018 = await d3.csv("2018.csv");
        let data2019 = await d3.csv("2019.csv");

        // CLEAN THE DATASETS
        data2015 = data2015.map(function(country) {
          return { Country: country["Country"],
                   Freedom: country["Freedom"],
                   Gdp: country["Economy (GDP per Capita)"],
                   Generosity: country["Generosity"],
                   Life_expectancy: country["Health (Life Expectancy)"],
                   Corruption: country["Trust (Government Corruption)"],
                   //Social_support:
                   Score: country["Happiness Score"]
                  }
        });
        data2016 = data2016.map(function(country) {
          return { Country: country["Country"],
                   Freedom: country["Freedom"],
                   Gdp: country["Economy (GDP per Capita)"],
                   Generosity: country["Generosity"],
                   Life_expectancy: country["Health (Life Expectancy)"],
                   Corruption: country["Trust (Government Corruption)"],
                   //Social_support:
                   Score: country["Happiness Score"]
                  }
        });
        data2017 = data2017.map(function(country) {
          return { Country: country["Country"],
                   Freedom: country["Freedom"],
                   Gdp: country["Economy..GDP.per.Capita."],
                   Generosity: country["Generosity"],
                   Life_expectancy: country["Health..Life.Expectancy."],
                   Corruption: country["Trust..Government.Corruption."],
                   //Social_support:
                   Score: country["Happiness.Score"]
                  }
        });
        data2018 = data2018.map(function(country) {
          return { Country: country["Country or region"],
                   Freedom: country["Freedom to make life choices"],
                   Gdp: country["GDP per capita"],
                   Generosity: country["Generosity"],
                   Life_expectancy: country["Healthy life expectancy"],
                   Corruption: country["Perceptions of corruption"],
                   //Social_support: country["Social support"],
                   Score: country["Score"]
                  }
        });
        data2019 = data2019.map(function(country) {
          return { Country: country["Country or region"],
                   Freedom: country["Freedom to make life choices"],
                   Gdp: country["GDP per capita"],
                   Generosity: country["Generosity"],
                   Life_expectancy: country["Healthy life expectancy"],
                   Corruption: country["Perceptions of corruption"],
                   //Social_support: country["Social support"],
                   Score: country["Score"]
                 }
        })

        // SORTING FUNCTION (to get countries in alphabet order)
            // Source: https://www.programiz.com/javascript/examples/sort-array-objects
        function compareName(a, b) {
          // converting to uppercase to have case-insensitive comparison
          const name1 = a.Country.toUpperCase();
          const name2 = b.Country.toUpperCase();

          let comparison = 0;

          if (name1 > name2) {
              comparison = 1;
          } else if (name1 < name2) {
              comparison = -1;
          }
          return comparison;
        }

        data2015 = data2015.sort(compareName);
        data2016 = data2016.sort(compareName);
        data2017 = data2017.sort(compareName);
        data2018 = data2018.sort(compareName);
        data2019 = data2019.sort(compareName);

        // CLEAN THE DATA
        let i = data2015.findIndex((element) => (element["Country"] == "United States"));
        data2015[i]["Country"] = "United States of America"
        let i2 = data2016.findIndex((element) => (element["Country"] == "United States"));
        data2016[i2]["Country"] = "United States of America"
        let i3 = data2017.findIndex((element) => (element["Country"] == "United States"));
        data2017[i3]["Country"] = "United States of America"
        let i4 = data2018.findIndex((element) => (element["Country"] == "United States"));
        data2018[i4]["Country"] = "United States of America"
        let i5 = data2019.findIndex((element) => (element["Country"] == "United States"));
        data2019[i5]["Country"] = "United States of America"


        const svg_LC = d3.select("svg#linePlot");
        const width_LC = svg_LC.attr("width");
        const height_LC = svg_LC.attr("height");
        const margin_LC = {top: 30, right: 40, bottom: 80, left: 40};
        const chartWidth_LC = width_LC - margin_LC.left - margin_LC.right;
        const chartHeight_LC = height_LC - margin_LC.top - margin_LC.bottom;

        let years = [
          {"Year": 2015},
          {"Year": 2016},
          {"Year": 2017},
          {"Year": 2018},
          {"Year": 2019}]

        svg_LC.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", width_LC)
            .attr("height", height_LC)
            .attr("fill", "lightgrey")
            .attr("rx", 20)
            .attr("ry", 20)

        let annotations_LC = svg_LC.append("g").attr("id","annotations");
        let chartArea_LC = svg_LC.append("g").attr("id","points")
                        .attr("transform",`translate(${margin_LC.left},${margin_LC.top})`);

        // Y-AXIS (axisLeft)
        //const freedomExtent = d3.extent(  );
        const freedomScale = d3.scaleLinear().domain([0,2]).range([chartHeight_LC, 0]);
        let leftAxis_LC = d3.axisLeft(freedomScale)
        let leftGridlines_LC = d3.axisLeft(freedomScale)
                              .tickSize(-chartWidth_LC-10)
                              .tickFormat("")



        // X-AXIS (axisBottom)
        const timeExtent = d3.extent(years, d => d['Year']);
        const timeScale = d3.scaleLinear().domain(timeExtent).range([0, chartWidth_LC]);
        let bottomAxis_LC = d3.axisBottom(timeScale)
          .tickFormat(d3.format("d"))
          .ticks(5)
        let bottomGridlines_LC = d3.axisBottom(timeScale)
                                .tickSize(-chartHeight_LC-10)
                                .tickFormat("")
                                .ticks(5)


        function setChart(){
          chartArea_LC.append("rect")
              .attr("x", -25)
              .attr("y", -10)
              .attr("width", width_LC)
              .attr("height", height_LC)
              .attr("fill", "lightgrey")


          //draw background
          chartArea_LC.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", chartWidth_LC)
            .attr("height", chartHeight_LC)
            .attr("fill", "lightgrey");

          //Y-axis
          chartArea_LC.append("g")
            .attr("class", "y axis")
            //.attr("transform",`translate(${margin_LC.left-10},${margin_LC.top})`)
            .call(leftAxis_LC)
          chartArea_LC.append("g")
            .attr("class", "y gridlines")
            //.attr("transform",`translate(${margin_LC.left-10},${margin_LC.top})`)
            .call(leftGridlines_LC);

          //X-axis
          chartArea_LC.append("g")
            .attr("class", "x axis")
            .attr("transform",`translate(${0},${chartHeight_LC+0})`)
            .call(bottomAxis_LC);
          chartArea_LC.append("g")
            .attr("class", "x gridlines")
            .attr("transform",`translate(${0},${chartHeight_LC+0})`)
            .style("stroke", "grey")
            .call(bottomGridlines_LC);

        }

        // LINE GENERATORS
        let freedomLineGen = d3.line()
              .x( d => timeScale(d['Year']) )
              .y( d => freedomScale(d["Freedom"]) )
        let gdpLineGen = d3.line()
               .x( d => timeScale(d['Year']) )
               .y( d => freedomScale(d["Gdp"]) )
        let generosityLineGen = d3.line()
                .x( d => timeScale(d['Year']) )
                .y( d => freedomScale(d["Generosity"]) )
        let lifeLineGen = d3.line()
               .x( d => timeScale(d['Year']) )
               .y( d => freedomScale(d["Life_expectancy"]) )
        let corruptionLineGen = d3.line()
              .x( d => timeScale(d['Year']) )
              .y( d => freedomScale(d["Corruption"]) )
        let socialLineGen = d3.line()
               .x( d => timeScale(d['Year']) )
               .y( d => freedomScale(d["Social_support"]) )

        function lineChart(line_country){
          let isFinland = (element) => (element["Country"] == line_country);
          let i_15 = data2015.findIndex(isFinland);
          let i_16 = data2016.findIndex(isFinland);
          let i_17 = data2017.findIndex(isFinland);
          let i_18 = data2018.findIndex(isFinland);
          let i_19 = data2019.findIndex(isFinland);

          // get the data 2015-2019 for each country
          let Finland_data = [
            { "Country": line_country,
              "Year": 2015,
              "Freedom": data2015[i_15]["Freedom"],
              "Gdp": data2015[i_15]["Gdp"],
              "Generosity": data2015[i_15]["Generosity"],
              "Life_expectancy": data2015[i_15]["Life_expectancy"],
              "Corruption": data2015[i_15]["Corruption"]
            },
            { "Country": line_country,
              "Year": 2016,
              "Freedom": data2016[i_16]["Freedom"],
              "Gdp": data2016[i_16]["Gdp"],
              "Generosity": data2016[i_16]["Generosity"],
              "Life_expectancy": data2016[i_16]["Life_expectancy"],
              "Corruption": data2016[i_16]["Corruption"]
            },
            { "Country": line_country,
              "Year": 2017,
              "Freedom": data2017[i_17]["Freedom"],
              "Gdp": data2017[i_17]["Gdp"],
              "Generosity": data2017[i_17]["Generosity"],
              "Life_expectancy": data2017[i_17]["Life_expectancy"],
              "Corruption": data2017[i_17]["Corruption"]
            },
            { "Country": line_country,
              "Year": 2018,
              "Freedom": data2018[i_18]["Freedom"],
              "Gdp": data2018[i_18]["Gdp"],
              "Generosity": data2018[i_18]["Generosity"],
              "Life_expectancy": data2018[i_18]["Life_expectancy"],
              "Corruption": data2018[i_18]["Corruption"]
            },
            { "Country": line_country,
              "Year": 2019,
              "Freedom": data2019[i_19]["Freedom"],
              "Gdp": data2019[i_19]["Gdp"],
              "Generosity": data2019[i_19]["Generosity"],
              "Life_expectancy": data2019[i_19]["Life_expectancy"],
              "Corruption": data2019[i_19]["Corruption"]
            }
          ]

          // generator the lines for each component for that country
          Finland_data.forEach( (d, i) => {

            chartArea_LC.append("path")
             .datum(Finland_data)
             .attr("class", "line")
             .attr("fill", "none")
             .attr("stroke", "#66c2a5")
             .attr("stroke-width", 3)
             //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
             .attr("d", freedomLineGen);
            chartArea_LC.append("path")
                .datum(Finland_data)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "#fc8d62")
                .attr("stroke-width", 3)
                //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
                .attr("d", gdpLineGen);
            chartArea_LC.append("path")
                .datum(Finland_data)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "#8da0cb")
                .attr("stroke-width", 3)
                //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
                .attr("d", generosityLineGen);
            chartArea_LC.append("path")
                .datum(Finland_data)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "#e78ac3")
                .attr("stroke-width", 3)
                //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
                .attr("d", lifeLineGen);
            chartArea_LC.append("path")
                .datum(Finland_data)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "#ffd92f")
                .attr("stroke-width", 3)
                //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
                .attr("d", corruptionLineGen);
            chartArea_LC.append("path")
                .datum(Finland_data)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "#e5c494")
                .attr("stroke-width", 3)
                //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
                .attr("d", socialLineGen);

          });
        }

        function global_lines(){
          setChart();

          const global_freedom = [
            {"Year": 2015, "Freedom": data2015.reduce((accumulator, object) => { return accumulator + Number(object["Freedom"]);}, 0)/data2015.length},
            {"Year": 2016, "Freedom": data2016.reduce((accumulator, object) => { return accumulator + Number(object["Freedom"]);}, 0)/data2016.length},
            {"Year": 2017, "Freedom": data2017.reduce((accumulator, object) => { return accumulator + Number(object["Freedom"]);}, 0)/data2017.length},
            {"Year": 2018, "Freedom": data2018.reduce((accumulator, object) => { return accumulator + Number(object["Freedom"]);}, 0)/data2018.length},
            {"Year": 2019, "Freedom": data2019.reduce((accumulator, object) => { return accumulator + Number(object["Freedom"]);}, 0)/data2019.length}
          ]
          const global_gdp = [
            {"Year": 2015, "Gdp": data2015.reduce((accumulator, object) => { return accumulator + Number(object["Gdp"]);}, 0)/data2015.length},
            {"Year": 2016, "Gdp": data2016.reduce((accumulator, object) => { return accumulator + Number(object["Gdp"]);}, 0)/data2016.length},
            {"Year": 2017, "Gdp": data2017.reduce((accumulator, object) => { return accumulator + Number(object["Gdp"]);}, 0)/data2017.length},
            {"Year": 2018, "Gdp": data2018.reduce((accumulator, object) => { return accumulator + Number(object["Gdp"]);}, 0)/data2018.length},
            {"Year": 2019, "Gdp": data2019.reduce((accumulator, object) => { return accumulator + Number(object["Gdp"]);}, 0)/data2019.length}
          ]
          const global_generosity = [
            {"Year": 2015, "Generosity": data2015.reduce((accumulator, object) => { return accumulator + Number(object["Generosity"]);}, 0)/data2015.length},
            {"Year": 2016, "Generosity": data2016.reduce((accumulator, object) => { return accumulator + Number(object["Generosity"]);}, 0)/data2016.length},
            {"Year": 2017, "Generosity": data2017.reduce((accumulator, object) => { return accumulator + Number(object["Generosity"]);}, 0)/data2017.length},
            {"Year": 2018, "Generosity": data2018.reduce((accumulator, object) => { return accumulator + Number(object["Generosity"]);}, 0)/data2018.length},
            {"Year": 2019, "Generosity": data2019.reduce((accumulator, object) => { return accumulator + Number(object["Generosity"]);}, 0)/data2019.length}
          ]
          const global_life = [
            {"Year": 2015, "Life_expectancy": data2015.reduce((accumulator, object) => { return accumulator + Number(object["Life_expectancy"]);}, 0)/data2015.length},
            {"Year": 2016, "Life_expectancy": data2016.reduce((accumulator, object) => { return accumulator + Number(object["Life_expectancy"]);}, 0)/data2016.length},
            {"Year": 2017, "Life_expectancy": data2017.reduce((accumulator, object) => { return accumulator + Number(object["Life_expectancy"]);}, 0)/data2017.length},
            {"Year": 2018, "Life_expectancy": data2018.reduce((accumulator, object) => { return accumulator + Number(object["Life_expectancy"]);}, 0)/data2018.length},
            {"Year": 2019, "Life_expectancy": data2019.reduce((accumulator, object) => { return accumulator + Number(object["Life_expectancy"]);}, 0)/data2019.length}
          ]
          const global_corruption = [
            {"Year": 2015, "Corruption": data2015.reduce((accumulator, object) => { return accumulator + Number(object["Corruption"]);}, 0)/data2015.length},
            {"Year": 2016, "Corruption": data2016.reduce((accumulator, object) => { return accumulator + Number(object["Corruption"]);}, 0)/data2016.length},
            {"Year": 2017, "Corruption": data2017.reduce((accumulator, object) => { return accumulator + Number(object["Corruption"]);}, 0)/data2017.length},
            //{"Year": 2018, "Corruption": data2018.reduce((accumulator, object) => { return accumulator + Number(object["Corruption"]);}, 0)/data2018.length},
            // 2018 returns NaN...
            {"Year": 2019, "Corruption": data2019.reduce((accumulator, object) => { return accumulator + Number(object["Corruption"]);}, 0)/data2019.length}
          ]
          const global_social = [
            {"Year": 2015, "Social_support": data2015.reduce((accumulator, object) => { return accumulator + Number(object["Social_support"]);}, 0)/data2015.length},
            {"Year": 2016, "Social_support": data2016.reduce((accumulator, object) => { return accumulator + Number(object["Social_support"]);}, 0)/data2016.length},
            {"Year": 2017, "Social_support": data2017.reduce((accumulator, object) => { return accumulator + Number(object["Social_support"]);}, 0)/data2017.length},
            {"Year": 2018, "Social_support": data2018.reduce((accumulator, object) => { return accumulator + Number(object["Social_support"]);}, 0)/data2018.length},
            {"Year": 2019, "Social_support": data2019.reduce((accumulator, object) => { return accumulator + Number(object["Social_support"]);}, 0)/data2019.length}
          ]

          console.log(data2018.reduce((accumulator, object) => { return accumulator + Number(object["Corruption"]);}, 0))

          chartArea_LC.append("path")
           .datum(global_freedom)
           .attr("class", "line")
           .attr("fill", "none")
           .attr("stroke", "#66c2a5")
           .attr("stroke-width", 3)
           //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
           .attr("d", freedomLineGen);

          chartArea_LC.append("path")
            .datum(global_gdp)
            .attr("class", "line")
            .attr("fill", "none")
            .attr("stroke", "#fc8d62")
            .attr("stroke-width", 3)
            //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
            .attr("d", gdpLineGen);

          chartArea_LC.append("path")
             .datum(global_generosity)
             .attr("class", "line")
             .attr("fill", "none")
             .attr("stroke", "#8da0cb")
             .attr("stroke-width", 3)
             //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
             .attr("d", generosityLineGen);

          chartArea_LC.append("path")
              .datum(global_life)
              .attr("class", "line")
              .attr("fill", "none")
              .attr("stroke", "#e78ac3")
              .attr("stroke-width", 3)
              //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
              .attr("d", lifeLineGen);

          chartArea_LC.append("path")
              .datum(global_corruption)
              .attr("class", "line")
              .attr("fill", "none")
              .attr("stroke", "#ffd92f")
              .attr("stroke-width", 3)
              //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
              .attr("d", corruptionLineGen);

          chartArea_LC.append("path")
              .datum(global_social)
              .attr("class", "line")
              .attr("fill", "none")
              .attr("stroke", "#e5c494")
              .attr("stroke-width", 3)
              //.attr("transform",`translate(${margin_LC.left},${margin_LC.top})`)
              .attr("d", socialLineGen);

        }
        global_lines();

        // ----------------- END OF LINE CHART STUFF OUTSIDE OF CLICK-------------------


        // ON CLICK Function
        mycountries.on("click", function() {
          setChart();

          // redraw the background...
          let background = chartArea.append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", chartWidth)
              .attr("height", chartHeight)
              .attr("fill", "lightgrey")
              .attr("rx", 20)
              .attr("ry", 20)

          // country name drawn
          var name = chartArea.append("text")
              .attr("x", width/2)
              .attr("y", 50)
              .attr("text-anchor", "middle")
              .attr("font-family", "Verdana, sans-serif")
              .style("font-size", 25)
              .style("opacity", "1")
              .text(d3.select(this).datum().properties.name)

          // --- Pie Chart appears ---
          try { // TRY-CATCH FOR PIE CHART
            this_country = happinessreport.filter(d => d["Country or region"] == d3.select(this).datum().properties.name);

            let rank = this_country[0]["Overall rank"];
            let happiness_score = this_country[0]["Score"];

            pie_data[0] = this_country[0]["Freedom to make life choices"];
            pie_data[1] = this_country[0]["GDP per capita"];
            pie_data[2] = this_country[0]["Generosity"];
            pie_data[3] = this_country[0]["Healthy life expectancy"];
            pie_data[4] = this_country[0]["Perceptions of corruption"];
            pie_data[5] = this_country[0]["Social support"];

            let arcs = chartArea.selectAll("arc")
                      .data(pie(pie_data))
                      .enter()
                      .append("g")
                      .attr("class", "arc")
                      .attr("transform",`translate(${width/2},${2*height/5})`);

            arcs.append("path")
              .attr("fill", function(d, i) {
                  return pie_color(i);
              })
              .attr("d", arc);

            // --- UPDATE PIE CHART DICTIONARY ---
            data_dict[0]["value"] = pie_data[0];
            data_dict[1]["value"] = pie_data[1];
            data_dict[2]["value"] = pie_data[2];
            data_dict[3]["value"] = pie_data[3];
            data_dict[4]["value"] = pie_data[4];
            data_dict[5]["value"] = pie_data[5];

            // --- UPDATE PIE CHART LEGEND ---
            pie_key(data_dict, happiness_score);

            // Country Rank
            chartArea.append("text")
                .attr("x", width/2)
                .attr("y", 80)
                .attr("text-anchor", "middle")
                .attr("font-family", "Verdana, sans-serif")
                .style("font-size", 20)
                .style("opacity", "1")
                .text("#" + rank + " Happiest Nation")

          }

          catch (TypeError) { // TRY-CATCH FOR PIE CHART
              // console.log("Country has no data")
              chartArea.append("text")
                  .attr("x", width/2)
                  .attr("y", 200)
                  .attr("text-anchor", "middle")
                  .attr("font-family", "Verdana, sans-serif")
                  .style("font-size", 15)
                  .style("opacity", "1")
                  .text("Happiness data not available for this country.")
            }

          // ------------------------- LINE CHART ON CLICK ------------------------------

          try { //LINE CHART TRY CATCH
            let line_country = d3.select(this).datum().properties.name;

            lineChart(line_country);
          }
          catch(TypeError){ //TRY-CATCH FOR LINE CHART
            chartArea_LC.append("text")
                .attr("x", chartWidth_LC/2)
                .attr("y", 200)
                .attr("text-anchor", "middle")
                .attr("font-family", "Verdana, sans-serif")
                .style("font-size", 12)
                .style("opacity", "1")
                .text("Data (2015-2019) not available for this country.")
          }

          // title of graph as the country
          /*
          chartArea_LC.append("text")
            .attr("x", width/2)
            .attr("y", -5)
            .attr("text-anchor", "middle")
            .attr("font-size", 30)
            .text(line_country);
          */

          // ------------------------- END OF LINE CHART ON CLICK ------------------------------

          // Map Visual Feedback
          // If country selected is a country with no data, set all opacities to 1
          if (d3.select(this).style("fill") === "rgb(211, 211, 211)") {
            mycountries.attr("opacity", 1);
          }
          // If map opacity is 1 and a country is clicked, set rest of opacities to 0.6
          else if ( parseFloat(d3.select(this).style("opacity")) === 1 &&
                    parseFloat(d3.select(".countries").style("opacity")) === 1 ) {
            mycountries.attr("opacity", 0.6);
            d3.select(this).attr("opacity", 1);
          }
          // If map opacity is 0.6 and a country is reclicked, set all opacities to 1, and return secondary graphs to global values
          else if ( parseFloat(d3.select(this).style("opacity")) === 1 &&
                    parseFloat(d3.select(".countries").style("opacity")) === 0.6 ) {
            mycountries.attr("opacity", 1);
            global_pie();
            global_lines();
            pie_key(data_dict, happiness_score);
          }
          // If a country with opacity 0.6 is clicked, set that as target
          else if (parseFloat(d3.select(this).style("opacity")) === 0.6) {
            mycountries.attr("opacity", 0.6);
            d3.select(this).attr("opacity", 1);
          }

        }); // END OF ON CLICK


        mycountries.on("mouseover", function() {
          d3.select(this).attr("stroke","black")
                         .attr("stroke-width", 1.5);
        });

        mycountries.on("mouseout", function() {
          d3.select(this).attr("stroke","black")
                         .attr("stroke-width", 0.5);
        });

      } // end of async function

      drawMap();

    </script>
  </p>

    <!--- VISUALIZATION 2 -->
  <p id="p2">

    <svg id="scatterplot" width="800" height="500"></svg>
    <script>
        const svg = d3.select("svg#scatterplot").attr("width", 800).attr("height", 500);
        const width = svg.attr("width");
        const height = svg.attr("height");

        const margins = {top: 10, right: 10, bottom: 50, left: 50};
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom - 50;

        let annotations = svg.append("g").attr("id","annotations");
        let chart = svg.append('g')
        let chartArea = svg.append("g").attr("id","points")
                                .attr('transform',`translate(${margins.left},${margins.top})`);

        d3.csv("2019.csv", d3.autoType).then((data => {
          //console.log(data)
          data = data.filter(d=> { return !(d['region_1'] === 'NA' || d['region_1'] === 'N/A')})
          data.forEach(d => {
                d['Freedom to make life choices'] = Number(d['Freedom to make life choices'])
                d['GDP per capita'] = Number(d['GDP per capita'])
            })

            const freedomExtent = d3.extent(data, d => d['Freedom to make life choices']);

            const gdpExtent = d3.extent(data, d => d['GDP per capita']);


            let xScale = d3.scaleLinear().domain(freedomExtent).range([20, chartWidth]);
            let yScale = d3.scaleLinear().domain(gdpExtent).range([chartHeight, 0]);
            const colorScale = d3.scaleOrdinal(d3.schemeGnBu);

            let leftAxis = d3.axisLeft(yScale);
            chart.append('g')
                .attr('transform',`translate(${margins.left+20},${margins.top})`)
                .call(leftAxis);

            let leftGridlines = d3.axisLeft(yScale).tickFormat("").tickSize(-chartWidth-10);
            chart.append('g')
                .attr('transform',`translate(${margins.left+20},${margins.top})`)
                .call(leftGridlines);

            let bottomAxis = d3.axisBottom(xScale);
            chart.append('g')
                .attr('transform',`translate(${margins.left},${chartHeight+margins.top})`)
                .call(bottomAxis);

            let bottomGridlines = d3.axisBottom(xScale).tickFormat("").tickSize(-chartHeight-10);
            chart.append('g')
                .attr('transform',`translate(${margins.left},${chartHeight+margins.top})`)
                .call(bottomGridlines);

            let xlabel = annotations.append('text')
            .attr("x", chartWidth/2)
            .attr("y", 450)
            .attr("text-anchor", "middle")
            .attr("font-family", "Verdana, sans-serif")
            .style("font-size", 20)
            .text("Freedom to make life choices");

            let ylabel = annotations.append('text')
            .attr("transform", "translate(30," + chartHeight/2 + ")rotate(270)")
            .attr("text-anchor", "middle")
            .attr("font-family", "Verdana, sans-serif")
            .style("font-size", 20)
            .text("GDP per capita");

            const jitter = () => (Math.random() * 7) - 4;

            data.forEach(function(d, i) {
                let circle = chartArea.append("circle")
                        .attr('cx', xScale(d['Freedom to make life choices']) + jitter())
                        .attr('cy', yScale(d['GDP per capita'])+ jitter())
                        .attr('r', 6)
                        .attr('opacity', 0.5)
                        .style('fill', colorScale(d.Score))

                circle.on('mouseover', function() {
                    d3.select(this)
                    .transition()
                    .duration(300)
                    .attr('r', 8)
                    annotations.append('text')
                            .attr('class', 'scatter')
                            .attr('x', 600)
                            .attr('y', 25)
                            .attr("text-anchor", "middle")
                            .attr("font-family", "Verdana, sans-serif")
                            .style("font-size", 20)
                            .text(d['Country or region'])
                })

                circle.on('mouseout', function() {
                    d3.select(this)
                    .transition()
                    .duration(300)
                    .attr('r', 6)
                    d3.selectAll('.scatter').remove();
                })
        })
      }))
    </script>
  </p>

  <p id="3">
    <svg id="linePlot" width="500" height="500"></svg>
      <script>

        const loadData = async () => {
            let data2015 = await d3.csv("2015.csv");
            let data2016 = await d3.csv("2016.csv");
            let data2017 = await d3.csv("2017.csv");
            let data2018 = await d3.csv("2018.csv");
            let data2019 = await d3.csv("2019.csv");

            // CLEAN THE DATASETS
            data2015 = data2015.map(function(country) {
              return { Country: country["Country"],
                       Freedom: country["Freedom"],
                       Gdp: country["Economy (GDP per Capita)"],
                       Generosity: country["Generosity"],
                       Life_expectancy: country["Health (Life Expectancy)"],
                       Corruption: country["Trust (Government Corruption)"],
                       //Social_support:
                       Score: country["Happiness Score"]
                      }
            });
            data2016 = data2016.map(function(country) {
              return { Country: country["Country"],
                       Freedom: country["Freedom"],
                       Gdp: country["Economy (GDP per Capita)"],
                       Generosity: country["Generosity"],
                       Life_expectancy: country["Health (Life Expectancy)"],
                       Corruption: country["Trust (Government Corruption)"],
                       //Social_support:
                       Score: country["Happiness Score"]
                      }
            });
            data2017 = data2017.map(function(country) {
              return { Country: country["Country"],
                       Freedom: country["Freedom"],
                       Gdp: country["Economy..GDP.per.Capita."],
                       Generosity: country["Generosity"],
                       Life_expectancy: country["Health..Life.Expectancy."],
                       Corruption: country["Trust..Government.Corruption."],
                       //Social_support:
                       Score: country["Happiness.Score"]
                      }
            });
            data2018 = data2018.map(function(country) {
              return { Country: country["Country or region"],
                       Freedom: country["Freedom to make life choices"],
                       Gdp: country["GDP per capita"],
                       Generosity: country["Generosity"],
                       Life_expectancy: country["Healthy life expectancy"],
                       Corruption: country["Perceptions of corruption"],
                       //Social_support: country["Social support"],
                       Score: country["Score"]
                      }
            });
            data2019 = data2019.map(function(country) {
              return { Country: country["Country or region"],
                       Freedom: country["Freedom to make life choices"],
                       Gdp: country["GDP per capita"],
                       Generosity: country["Generosity"],
                       Life_expectancy: country["Healthy life expectancy"],
                       Corruption: country["Perceptions of corruption"],
                       //Social_support: country["Social support"],
                       Score: country["Score"]
                     }
            })

            // SORTING FUNCTION (to get countries in alphabet order)
                // Source: https://www.programiz.com/javascript/examples/sort-array-objects
            function compareName(a, b) {
              // converting to uppercase to have case-insensitive comparison
              const name1 = a.Country.toUpperCase();
              const name2 = b.Country.toUpperCase();

              let comparison = 0;

              if (name1 > name2) {
                  comparison = 1;
              } else if (name1 < name2) {
                  comparison = -1;
              }
              return comparison;
            }

            data2015 = data2015.sort(compareName);
            data2016 = data2016.sort(compareName);
            data2017 = data2017.sort(compareName);
            data2018 = data2018.sort(compareName);
            data2019 = data2019.sort(compareName);

            //TODO: DELETE INCONSISTENT COUNTRIES NOT IN 2019

            /*
            // Countries to drop from 2015: Angola, Djibouti,
            data2015 = data2015.filter(d =>
              d["Country"] != 'Angola' &&
              d["Country"] != 'Djibouti' &&
              d["Country"] != 'Oman'
            );
            */

            // Countries to rename in 2015: Macedonia, North Cyprus, Somaliland region, Trinidad and Tobago
            let i = data2015.findIndex((element) => (element["Country"] == "Macedonia"));
            data2015[i]["Country"] = "North Macedonia" // "Macedonia"

            //console.log("cleaned 2015:")
            //console.log(data2015);
            //console.log(data2016);
            //console.log(data2017);
            //console.log(data2018);
            //console.log("cleaned 2019:")
            //console.log(data2019);

            // ------------ TEST THE CLEANING -------------
            //Find inconsistent countries based on 2019
            let countries2015 = [];
            data2015.forEach( (d, i) => {
              countries2015.push(d["Country"]);
            });
            let countries2016 = [];
            data2016.forEach( (d, i) => {
              countries2016.push(d["Country"]);
            });
            let countries2017 = [];
            data2017.forEach( (d, i) => {
              countries2017.push(d["Country"]);
            });
            let countries2018 = [];
            data2018.forEach( (d, i) => {
              countries2018.push(d["Country"]);
            });
            let countries2019 = [];
            data2019.forEach( (d, i) => {
              countries2019.push(d["Country"]);
            });

            const countriesin2015not2019 = countries2015.filter(element => !countries2019.includes(element));
              // ['Angola', 'Djibouti', 'Macedonia', 'North Cyprus', 'Oman',
              // 'Somaliland region', 'Sudan', 'Suriname', 'Trinidad and Tobago']
            const countriesin2019not2015 = countries2019.filter(element => !countries2015.includes(element));
            //['Gambia', 'Namibia', 'North Macedonia', 'Northern Cyprus', 'Somalia', 'South Sudan', 'Trinidad & Tobago']

            //console.log(countriesin2015not2019);
        };
        loadData();
      </script>

  </p>

</body>
